---
title: 2.1 S Principio De Responsabilidad Única
published: 2025-10-01
tags: [DisenoEImplementacionSoftwareConPatrones, IngenieriaDeSoftware, Java, Python, Django, SpringBoot, ITO]
category: DisenoEImplementacionSoftwareConPatrones
draft: false
---

# S: Principio de Responsabilidad Única (Single Responsibility Principle)

## Definición

El **Principio de Responsabilidad Única (SRP)** establece que:
**“Una clase debe tener una sola razón para cambiar”.**

Cada clase debe encargarse de una única parte de la funcionalidad y encapsular completamente esa responsabilidad.
El objetivo principal es **reducir la complejidad** y hacer el código más **mantenible** y **fácil de probar**.

## Motivación

* Si una clase hace demasiadas cosas, tendrás que modificarla constantemente.
* Esto aumenta el riesgo de romper otras partes del sistema.
* Dividir responsabilidades facilita la **lectura**, la **extensión** y la **navegación del código**.

## Ejemplo conceptual

Clase `Empleado` con dos responsabilidades:

1. Gestionar datos del empleado.
2. Generar reportes de horas trabajadas.

Esto genera múltiples razones de cambio.
La solución es **separar responsabilidades**: una clase para manejar empleados y otra para generar reportes.

---

## Ejemplo en Spring Boot (Java, IntelliJ IDEA)

### Antes (violando SRP)

```java
@Service
public class EmployeeService {

    public void saveEmployee(String name) {
        System.out.println("Empleado guardado: " + name);
    }

    public void printWorkReport(String name) {
        System.out.println("Reporte de horas trabajado para: " + name);
    }
}
```

### Después (aplicando SRP)

```java
@Service
public class EmployeeService {
    public void saveEmployee(String name) {
        System.out.println("Empleado guardado: " + name);
    }
}

@Service
public class ReportService {
    public void printWorkReport(String name) {
        System.out.println("Reporte de horas trabajado para: " + name);
    }
}
```

Ahora:

* `EmployeeService` solo maneja empleados.
* `ReportService` se encarga de los reportes.

---

## Ejemplo en Django (Python, PyCharm)

### Antes (violando SRP)

```python
class EmployeeService:
    def save_employee(self, name):
        print(f"Empleado guardado: {name}")

    def print_work_report(self, name):
        print(f"Reporte de horas trabajado para: {name}")
```

### Después (aplicando SRP)

```python
class EmployeeService:
    def save_employee(self, name):
        print(f"Empleado guardado: {name}")

class ReportService:
    def print_work_report(self, name):
        print(f"Reporte de horas trabajado para: {name}")
```

Ahora:

* `EmployeeService` gestiona empleados.
* `ReportService` se encarga de reportes.

---

## Conclusión

El SRP ayuda a:

* Evitar clases con múltiples motivos de cambio.
* Mantener el código **modular** y **claro**.
* Reducir riesgos al modificar y extender el sistema.
