---
title: 2.10 Abstract Factory
published: 2025-10-09
tags: [DisenoEImplementacionSoftwareConPatrones, IngenieriaDeSoftware, Java, Python, Django, SpringBoot, ITO]
category: DisenoEImplementacionSoftwareConPatrones
draft: false
---

# Teor√≠a
## Definici√≥n

El **patr√≥n Abstract Factory** (F√°brica abstracta) es un patr√≥n creacional que permite **crear familias de objetos relacionados** sin especificar sus clases concretas.
La clave es encapsular el c√≥digo de creaci√≥n en f√°bricas, de manera que el cliente trabaje solo con **interfaces abstractas**, manteniendo compatibilidad y flexibilidad.

## Cu√°ndo usarlo

* Cuando necesitamos **grupos de productos relacionados** (botones, men√∫s, muebles, etc.) que deben funcionar juntos.
* Cuando queremos **evitar acoplamiento** con clases concretas.
* Cuando el sistema debe **cambiar de variantes f√°cilmente** (ej. estilos moderno/victoriano, Windows/Linux).

## Cu√°ndo no usarlo

* Si solo necesitamos **una familia de objetos** o un √∫nico producto.
* Si la creaci√≥n de objetos no cambia o no hay variantes.
* Cuando el patr√≥n a√±ade **complejidad innecesaria** para casos simples.

---

## Estructura (Mermaid)

```mermaid
classDiagram
    class AbstractFactory {
        <<interface>>
        +createChair(): Chair
        +createSofa(): Sofa
    }

    class ModernFurnitureFactory {
        +createChair(): Chair
        +createSofa(): Sofa
    }

    class VictorianFurnitureFactory {
        +createChair(): Chair
        +createSofa(): Sofa
    }

    class Chair {
        <<interface>>
        +sit()
    }

    class Sofa {
        <<interface>>
        +lieDown()
    }

    class ModernChair {
        +sit()
    }

    class VictorianChair {
        +sit()
    }

    class ModernSofa {
        +lieDown()
    }

    class VictorianSofa {
        +lieDown()
    }

    AbstractFactory <|.. ModernFurnitureFactory
    AbstractFactory <|.. VictorianFurnitureFactory
    Chair <|.. ModernChair
    Chair <|.. VictorianChair
    Sofa <|.. ModernSofa
    Sofa <|.. VictorianSofa
```

---

## Ejemplo en **Spring Boot (Java)**

```java
// Interfaces de productos
public interface Chair {
    void sit();
}

public interface Sofa {
    void lieDown();
}

// Implementaciones concretas
public class ModernChair implements Chair {
    public void sit() { System.out.println("Sentado en una silla moderna."); }
}

public class VictorianChair implements Chair {
    public void sit() { System.out.println("Sentado en una silla victoriana."); }
}

public class ModernSofa implements Sofa {
    public void lieDown() { System.out.println("Acostado en un sof√° moderno."); }
}

public class VictorianSofa implements Sofa {
    public void lieDown() { System.out.println("Acostado en un sof√° victoriano."); }
}

// Abstract Factory
public interface FurnitureFactory {
    Chair createChair();
    Sofa createSofa();
}

// F√°bricas concretas
public class ModernFurnitureFactory implements FurnitureFactory {
    public Chair createChair() { return new ModernChair(); }
    public Sofa createSofa() { return new ModernSofa(); }
}

public class VictorianFurnitureFactory implements FurnitureFactory {
    public Chair createChair() { return new VictorianChair(); }
    public Sofa createSofa() { return new VictorianSofa(); }
}

// Cliente (Spring Boot Service)
@Service
public class FurnitureService {
    private final FurnitureFactory factory;

    public FurnitureService() {
        // Aqu√≠ podr√≠a decidirse por configuraci√≥n
        this.factory = new ModernFurnitureFactory();
    }

    public void demo() {
        Chair chair = factory.createChair();
        Sofa sofa = factory.createSofa();
        chair.sit();
        sofa.lieDown();
    }
}
```

---

## Ejemplo en **Django (Python)**

```python
from abc import ABC, abstractmethod

# Interfaces
class Chair(ABC):
    @abstractmethod
    def sit(self): pass

class Sofa(ABC):
    @abstractmethod
    def lie_down(self): pass

# Implementaciones concretas
class ModernChair(Chair):
    def sit(self):
        return "Sentado en una silla moderna"

class VictorianChair(Chair):
    def sit(self):
        return "Sentado en una silla victoriana"

class ModernSofa(Sofa):
    def lie_down(self):
        return "Acostado en un sof√° moderno"

class VictorianSofa(Sofa):
    def lie_down(self):
        return "Acostado en un sof√° victoriano"

# Abstract Factory
class FurnitureFactory(ABC):
    @abstractmethod
    def create_chair(self) -> Chair: pass

    @abstractmethod
    def create_sofa(self) -> Sofa: pass

# F√°bricas concretas
class ModernFurnitureFactory(FurnitureFactory):
    def create_chair(self): return ModernChair()
    def create_sofa(self): return ModernSofa()

class VictorianFurnitureFactory(FurnitureFactory):
    def create_chair(self): return VictorianChair()
    def create_sofa(self): return VictorianSofa()

# Cliente en Django (ejemplo en views.py)
from django.http import JsonResponse

def furniture_demo(request):
    factory = ModernFurnitureFactory()  # Podr√≠a cambiarse din√°micamente
    chair = factory.create_chair()
    sofa = factory.create_sofa()
    return JsonResponse({
        "chair": chair.sit(),
        "sofa": sofa.lie_down()
    })
```

---

## Resumen

* Abstract Factory permite **crear familias de productos consistentes** sin acoplar el c√≥digo a implementaciones concretas.
* Es √∫til en aplicaciones que necesitan **variantes intercambiables** (ej. estilos, SO, cat√°logos).
* Se aplica tanto en Java (Spring Boot) como en Python (Django) con interfaces y f√°bricas concretas.

# Pr√°ctica con Spring Boot
## Paso 1: Creaci√≥n del Proyecto en IntelliJ IDEA üöÄ

Primero, vamos a crear un proyecto nuevo y limpio.

1.  Abre IntelliJ IDEA y ve a **File** \> **New** \> **Project...**.

2.  En la ventana que aparece, selecciona **Spring Initializr** en el panel izquierdo.

3.  Configura los metadatos de tu proyecto. Puedes usar estos valores:

      * **Name**: `abstract-factory-ejemplo`
      * **Location**: La carpeta donde quieras guardarlo.
      * **Language**: **Java**
      * **Type**: **Gradle - Groovy** (o Maven si lo prefieres, ambos funcionar√°n).
      * **Group**: `com.example.solid`
      * **Artifact**: `abstract-factory-ejemplo`
      * **JDK**: Aseg√∫rate de seleccionar la **versi√≥n 17** (o superior).
      * **Packaging**: **Jar**

4.  Haz clic en **Next**.

5.  Ahora, elige las dependencias. Para este proyecto, solo necesitas una:

      * Busca y selecciona **Spring Web**.

6.  Haz clic en **Create**. IntelliJ generar√° la estructura del proyecto y descargar√° las dependencias.

-----

## Paso 2: Estructura de Paquetes üìÇ

Una buena organizaci√≥n es clave. Dentro de `src/main/java/com/example/solid/abstractfactoryejemplo`, crearemos los siguientes paquetes para mantener nuestro c√≥digo ordenado:

  * `products`: Contendr√° las interfaces de los productos (ej. `Silla`) y sus implementaciones concretas (ej. `SillaModerna`).
  * `factory`: Contendr√° la interfaz de la f√°brica abstracta (`MuebleriaFactory`) y sus implementaciones concretas (`MuebleriaModernaFactory`).
  * `controller`: Contendr√° nuestro `RestController`, que actuar√° como el cliente del patr√≥n.

-----

## Paso 3: Codificaci√≥n del Patr√≥n Abstract Factory üõãÔ∏è

Ahora vamos a escribir el c√≥digo, siguiendo la estructura que definimos.

### 3.1. Productos Abstractos (Interfaces)

Dentro del paquete `products`, crea estas dos interfaces. Ser√°n el contrato para nuestras familias de objetos.

**`Silla.java`**

```java
package com.example.solid.abstractfactoryejemplo.products;

public interface Silla {
    String sentarse();
}
```

**`Sofa.java`**

```java
package com.example.solid.abstractfactoryejemplo.products;

public interface Sofa {
    String recostarse();
}
```

### 3.2. Productos Concretos (Implementaciones)

En el mismo paquete `products`, crea las cuatro clases que implementan las interfaces anteriores. Estos son los objetos reales que construiremos.

**`SillaModerna.java`**

```java
package com.example.solid.abstractfactoryejemplo.products;

public class SillaModerna implements Silla {
    @Override
    public String sentarse() {
        return "Sentado c√≥modamente en una silla moderna.";
    }
}
```

**`SillaVictoriana.java`**

```java
package com.example.solid.abstractfactoryejemplo.products;

public class SillaVictoriana implements Silla {
    @Override
    public String sentarse() {
        return "Sentado con elegancia en una silla victoriana.";
    }
}
```

**`SofaModerno.java`**

```java
package com.example.solid.abstractfactoryejemplo.products;

public class SofaModerno implements Sofa {
    @Override
    public String recostarse() {
        return "Recostado en un sof√° de dise√±o minimalista.";
    }
}
```

**`SofaVictoriano.java`**

```java
package com.example.solid.abstractfactoryejemplo.products;

public class SofaVictoriano implements Sofa {
    @Override
    public String recostarse() {
        return "Descansando sobre un sof√° victoriano de terciopelo.";
    }
}
```

### 3.3. F√°brica Abstracta (Interfaz)

Ahora, en el paquete `factory`, crea la interfaz que define qu√© productos pueden crear nuestras f√°bricas.

**`MuebleriaFactory.java`**

```java
package com.example.solid.abstractfactoryejemplo.factory;

import com.example.solid.abstractfactoryejemplo.products.Silla;
import com.example.solid.abstractfactoryejemplo.products.Sofa;

public interface MuebleriaFactory {
    Silla crearSilla();
    Sofa crearSofa();
}
```

### 3.4. F√°bricas Concretas (Implementaciones)

En el mismo paquete `factory`, crea las f√°bricas que saben c√≥mo construir una familia de productos espec√≠fica (moderna o victoriana). **Las anotamos como `@Component` de Spring** para que el sistema las reconozca y las podamos inyectar despu√©s.

**`MuebleriaModernaFactory.java`**

```java
package com.example.solid.abstractfactoryejemplo.factory;

import com.example.solid.abstractfactoryejemplo.products.*;
import org.springframework.stereotype.Component;

@Component("moderna") // Nombre clave para identificar esta f√°brica
public class MuebleriaModernaFactory implements MuebleriaFactory {
    @Override
    public Silla crearSilla() {
        return new SillaModerna();
    }

    @Override
    public Sofa crearSofa() {
        return new SofaModerno();
    }
}
```

**`MuebleriaVictorianaFactory.java`**

```java
package com.example.solid.abstractfactoryejemplo.factory;

import com.example.solid.abstractfactoryejemplo.products.*;
import org.springframework.stereotype.Component;

@Component("victoriana") // Nombre clave para esta otra f√°brica
public class MuebleriaVictorianaFactory implements MuebleriaFactory {
    @Override
    public Silla crearSilla() {
        return new SillaVictoriana();
    }

    @Override
    public Sofa crearSofa() {
        return new SofaVictoriano();
    }
}
```

-----

## Paso 4: Crear el Cliente (Controlador REST) üåê

Finalmente, en el paquete `controller`, crearemos la clase que utiliza las f√°bricas para construir los productos. Usaremos la misma t√©cnica elegante del ejemplo anterior para que Spring nos inyecte todas las f√°bricas disponibles.

**`MuebleriaController.java`**

```java
package com.example.solid.abstractfactoryejemplo.controller;

import com.example.solid.abstractfactoryejemplo.factory.MuebleriaFactory;
import com.example.solid.abstractfactoryejemplo.products.Silla;
import com.example.solid.abstractfactoryejemplo.products.Sofa;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/muebles")
public class MuebleriaController {

    // Spring inyecta un mapa con todas las f√°bricas. La clave es el nombre
    // que pusimos en @Component ("moderna", "victoriana").
    private final Map<String, MuebleriaFactory> factories;

    @Autowired
    public MuebleriaController(Map<String, MuebleriaFactory> factories) {
        this.factories = factories;
    }

    @GetMapping("/crear/{estilo}")
    public ResponseEntity<?> crearMuebles(@PathVariable String estilo) {
        // Buscamos la f√°brica correcta seg√∫n el "estilo" de la URL.
        MuebleriaFactory factory = factories.get(estilo);

        if (factory == null) {
            return ResponseEntity.badRequest().body("Estilo de muebler√≠a no disponible: " + estilo);
        }

        // Usamos la f√°brica para crear la familia de productos.
        Silla silla = factory.crearSilla();
        Sofa sofa = factory.crearSofa();

        // Creamos una respuesta con los mensajes de los productos creados.
        Map<String, String> response = Map.of(
            "silla", silla.sentarse(),
            "sofa", sofa.recostarse(),
            "fabrica_usada", factory.getClass().getSimpleName()
        );

        return ResponseEntity.ok(response);
    }
}
```

-----

## Paso 5: Probar la Aplicaci√≥n ‚úÖ

¬°Todo est√° listo\!

1.  Ejecuta tu aplicaci√≥n desde la clase principal `AbstractFactoryEjemploApplication`.
2.  Usa un navegador o una herramienta como Postman para probar los siguientes endpoints:

<!-- end list -->

  * **Para obtener muebles modernos:**
    `http://localhost:8080/api/muebles/crear/moderna`

    **Respuesta esperada (JSON):**

    ```json
    {
        "silla": "Sentado c√≥modamente en una silla moderna.",
        "sofa": "Recostado en un sof√° de dise√±o minimalista.",
        "fabrica_usada": "MuebleriaModernaFactory"
    }
    ```

  * **Para obtener muebles victorianos:**
    `http://localhost:8080/api/muebles/crear/victoriana`

    **Respuesta esperada (JSON):**

    ```json
    {
        "silla": "Sentado con elegancia en una silla victoriana.",
        "sofa": "Descansando sobre un sof√° victoriano de terciopelo.",
        "fabrica_usada": "MuebleriaVictorianaFactory"
    }
    ```

  * **Para un estilo no existente:**
    `http://localhost:8080/api/muebles/crear/rustica`

    **Respuesta esperada:**
    `Estilo de muebler√≠a no disponible: rustica`

# Pr√°ctica con Django
## Paso 1: Creaci√≥n del Proyecto en PyCharm üöÄ

Primero, vamos a crear un proyecto Django nuevo y limpio.

1.  Abre **PyCharm** (versi√≥n Professional) y ve a **File** \> **New** \> **Project...**.
2.  En la ventana que aparece, selecciona **Django** en el panel izquierdo.
3.  Configura tu proyecto:
      * **Location**: Elige una carpeta y nombra el proyecto, por ejemplo, `abstract_factory_django`.
      * **New environment using**: Selecciona **Virtualenv**. Esto crear√° un entorno virtual aislado para tu proyecto.
      * **Application name**: Puedes nombrar tu primera aplicaci√≥n `core`.
4.  Haz clic en **Create**. PyCharm configurar√° el entorno, instalar√° Django y generar√° la estructura b√°sica del proyecto.

-----

## Paso 2: Estructura de Archivos y Aplicaci√≥n Django üìÇ

En Django, la l√≥gica se organiza en "apps". Crearemos una app espec√≠fica para nuestra muebler√≠a.

1.  Abre la **Terminal** dentro de PyCharm (**View** \> **Tool Windows** \> **Terminal**).
2.  Ejecuta el siguiente comando para crear una nueva app llamada `muebleria`:
    ```bash
    python manage.py startapp muebleria
    ```
3.  Ahora, registra esta nueva app en tu proyecto. Abre el archivo `abstract_factory_django/settings.py` y a√±ade `'muebleria'` a la lista de `INSTALLED_APPS`:
    ```python
    # abstract_factory_django/settings.py
    INSTALLED_APPS = [
        # ... otras apps
        'django.contrib.staticfiles',
        'muebleria', # A√±ade tu app aqu√≠
    ]
    ```

Dentro de la carpeta `muebleria`, organizaremos nuestro patr√≥n en diferentes archivos: `products.py`, `factories.py`, y modificaremos `views.py`.

-----

## Paso 3: Codificaci√≥n del Patr√≥n Abstract Factory üõãÔ∏è

Ahora vamos a escribir el c√≥digo Python. Usaremos el m√≥dulo `abc` para crear clases abstractas, que es el equivalente a las interfaces de Java para este prop√≥sito.

### 3.1. Productos Abstractos

1.  Dentro de la carpeta `muebleria`, crea un nuevo archivo llamado `products.py`.

2.  A√±ade el siguiente c√≥digo con las clases base para nuestros productos:

    **`muebleria/products.py`**

    ```python
    from abc import ABC, abstractmethod

    # Producto Abstracto 1
    class Silla(ABC):
        @abstractmethod
        def sentarse(self) -> str:
            pass

    # Producto Abstracto 2
    class Sofa(ABC):
        @abstractmethod
        def recostarse(self) -> str:
            pass

    # --- Implementaciones de la familia Moderna ---

    class SillaModerna(Silla):
        def sentarse(self) -> str:
            return "Sentado c√≥modamente en una silla moderna."

    class SofaModerno(Sofa):
        def recostarse(self) -> str:
            return "Recostado en un sof√° de dise√±o minimalista."

    # --- Implementaciones de la familia Victoriana ---

    class SillaVictoriana(Silla):
        def sentarse(self) -> str:
            return "Sentado con elegancia en una silla victoriana."

    class SofaVictoriano(Sofa):
        def recostarse(self) -> str:
            return "Descansando sobre un sof√° victoriano de terciopelo."
    ```

### 3.2. F√°bricas (Abstracta y Concretas)

1.  Dentro de la carpeta `muebleria`, crea otro archivo nuevo llamado `factories.py`.

2.  A√±ade el siguiente c√≥digo para definir las f√°bricas:

    **`muebleria/factories.py`**

    ```python
    from abc import ABC, abstractmethod
    from .products import (
        Silla, Sofa,
        SillaModerna, SofaModerno,
        SillaVictoriana, SofaVictoriano
    )

    # La F√°brica Abstracta
    class MuebleriaFactory(ABC):
        @abstractmethod
        def crear_silla(self) -> Silla:
            pass

        @abstractmethod
        def crear_sofa(self) -> Sofa:
            pass

    # F√°brica Concreta 1: para muebles modernos
    class MuebleriaModernaFactory(MuebleriaFactory):
        def crear_silla(self) -> Silla:
            return SillaModerna()

        def crear_sofa(self) -> Sofa:
            return SofaModerno()

    # F√°brica Concreta 2: para muebles victorianos
    class MuebleriaVictorianaFactory(MuebleriaFactory):
        def crear_silla(self) -> Silla:
            return SillaVictoriana()

        def crear_sofa(self) -> Sofa:
            return SofaVictoriano()
    ```

-----

## Paso 4: Crear el Cliente (La Vista de Django) üåê

El "cliente" en Django ser√° una vista que recibe la petici√≥n HTTP, elige la f√°brica correcta y devuelve una respuesta JSON.

Modifica el archivo `muebleria/views.py`.

**`muebleria/views.py`**

```python
from django.http import JsonResponse
from .factories import MuebleriaModernaFactory, MuebleriaVictorianaFactory

# Un mapa para registrar nuestras f√°bricas disponibles.
FABRICAS = {
    "moderna": MuebleriaModernaFactory,
    "victoriana": MuebleriaVictorianaFactory,
}

def crear_muebles(request, estilo: str):
    """
    Esta vista act√∫a como el cliente del patr√≥n Abstract Factory.
    """
    # 1. Busca la clase de la f√°brica correcta.
    fabrica_class = FABRICAS.get(estilo)

    if not fabrica_class:
        return JsonResponse({"error": f"Estilo de muebler√≠a no disponible: {estilo}"}, status=400)

    # 2. Instancia la f√°brica seleccionada.
    fabrica = fabrica_class()

    # 3. Usa la f√°brica para crear la familia de productos.
    silla = fabrica.crear_silla()
    sofa = fabrica.crear_sofa()

    # 4. Construye y devuelve la respuesta.
    response_data = {
        "silla": silla.sentarse(),
        "sofa": sofa.recostarse(),
        "fabrica_usada": fabrica.__class__.__name__
    }
    return JsonResponse(response_data)
```

-----

## Paso 5: Configurar las URLs üîó

Necesitamos decirle a Django qu√© URL debe activar nuestra vista.

1.  Dentro de la carpeta `muebleria`, crea un nuevo archivo `urls.py`.

    **`muebleria/urls.py`**

    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('crear/<str:estilo>/', views.crear_muebles, name='crear_muebles'),
    ]
    ```

2.  Ahora, incluye estas URLs en el archivo principal del proyecto.

    **`abstract_factory_django/urls.py`**

    ```python
    from django.contrib import admin
    from django.urls import path, include # Aseg√∫rate de importar "include"

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/muebles/', include('muebleria.urls')), # Conecta las URLs de tu app
    ]
    ```

-----

## Paso 6: Probar la Aplicaci√≥n ‚úÖ

¬°Todo est√° configurado\!

1.  En la terminal de PyCharm, ejecuta el servidor de desarrollo de Django:
    ```bash
    python manage.py runserver
    ```
2.  Usa un navegador o `curl` para probar los siguientes endpoints:

<!-- end list -->

  * **Para obtener muebles modernos:**
    `http://127.0.0.1:8000/api/muebles/crear/moderna/`

    **Respuesta esperada (JSON):**

    ```json
    {
        "silla": "Sentado c√≥modamente en una silla moderna.",
        "sofa": "Recostado en un sof√° de dise√±o minimalista.",
        "fabrica_usada": "MuebleriaModernaFactory"
    }
    ```

  * **Para obtener muebles victorianos:**
    `http://127.0.0.1:8000/api/muebles/crear/victoriana/`

    **Respuesta esperada (JSON):**

    ```json
    {
        "silla": "Sentado con elegancia en una silla victoriana.",
        "sofa": "Descansando sobre un sof√° victoriano de terciopelo.",
        "fabrica_usada": "MuebleriaVictorianaFactory"
    }
    ```

  * **Para un estilo no existente:**
    `http://127.0.0.1:8000/api/muebles/crear/rustica/`

    **Respuesta esperada (JSON con c√≥digo 400):**

    ```json
    {
        "error": "Estilo de muebler√≠a no disponible: rustica"
    }
    ```