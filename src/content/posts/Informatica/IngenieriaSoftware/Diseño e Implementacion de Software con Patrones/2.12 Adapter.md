---
title: 2.12 Adapter
published: 2025-10-14
tags: [DisenoEImplementacionSoftwareConPatrones, IngenieriaDeSoftware, Java, Python, Django, SpringBoot, ITO]
category: DisenoEImplementacionSoftwareConPatrones
draft: false
---

# Teor√≠a
## Definici√≥n 

El patr√≥n **Adapter (Adaptador o Envoltorio)** es un patr√≥n de dise√±o **estructural** que permite que objetos con **interfaces incompatibles** puedan colaborar. Funciona como un traductor o un intermediario: envuelve uno de los objetos para "ocultar" la complejidad de la conversi√≥n y presentar una interfaz consistente con la que el resto del sistema ya sabe c√≥mo trabajar.

-----

## Problema

Imagina que tu aplicaci√≥n procesa pagos y toda tu l√≥gica est√° construida alrededor de una interfaz est√°ndar `ProcesadorDePago` con un m√©todo `realizarPago()`. Ahora, decides integrar un nuevo proveedor de pagos muy popular, "SuperPago", que es excelente pero viene en una librer√≠a externa que no puedes modificar.

El problema es que la clase de "SuperPago" no sigue tu est√°ndar; su m√©todo se llama `ejecutarCobro()` y recibe los par√°metros en un formato diferente.

```java
// Tu sistema usa esta interfaz:
public interface ProcesadorDePago {
    void realizarPago(BigDecimal monto);
}

// La nueva librer√≠a tiene esta clase:
public class SuperPago {
    public void ejecutarCobro(String idCliente, double cantidad) {
        // ... l√≥gica del nuevo proveedor
    }
}
```

No puedes simplemente cambiar toda tu aplicaci√≥n para que use `ejecutarCobro()`, y tampoco puedes modificar la librer√≠a de `SuperPago`. Las interfaces son incompatibles.

-----

## Soluci√≥n

Creas una clase **Adaptador**.

1.  La nueva clase `SuperPagoAdapter` **implementar√°** tu interfaz est√°ndar `ProcesadorDePago`.
2.  Internamente, el `SuperPagoAdapter` **contendr√° una instancia** de la clase `SuperPago` (el objeto que necesita ser adaptado).
3.  Cuando tu sistema llame al m√©todo `realizarPago()` en el `SuperPagoAdapter`, el adaptador se encargar√° de **traducir esa llamada** al formato que `SuperPago` entiende, invocando `ejecutarCobro()` con los datos correctos.

De esta manera, el resto de tu aplicaci√≥n sigue trabajando con la interfaz `ProcesadorDePago` de siempre, sin siquiera saber que est√° interactuando con el sistema de "SuperPago" a trav√©s de un traductor.

-----

## Estructura (Mermaid UML)

El diagrama muestra c√≥mo el `Adapter` implementa la interfaz `Target` que el `Client` espera, mientras que internamente utiliza el `Adaptee` incompatible.

```mermaid
classDiagram
    direction LR

    class Client
    note for Client "Solo conoce la interfaz Target"

    class Target {
        <<Interface>>
        +request()
    }
    
    class Adapter {
        -adaptee: Adaptee
        +request()
    }
    note for Adapter "Implementa Target y traduce la llamada al Adaptee"

    class Adaptee {
        +specificRequest()
    }
    note for Adaptee "La clase existente con la interfaz incompatible"

    Client ..> Target : usa
    Target <|.. Adapter
    Adapter o-- Adaptee : envuelve
```

-----

## Cu√°ndo usar

  * Cuando necesitas usar una clase existente, pero su interfaz no es compatible con el resto de tu c√≥digo.
  * Cuando quieres reutilizar varias subclases existentes que carecen de una funcionalidad com√∫n que no puede ser a√±adida a su superclase.

## Cu√°ndo no usar

  * Cuando puedes modificar el c√≥digo fuente de ambos lados para que las interfaces coincidan. El adaptador a√±ade una capa de indirecci√≥n que puede ser innecesaria si tienes control total.

-----

## Ejemplo en Spring Boot (Java)

```java
// Target (La interfaz que tu sistema usa)
public interface ProcesadorDePago {
    String procesarPago(double monto);
}

// Adaptee (La clase externa con interfaz incompatible)
public class ProveedorExterno {
    public String realizarCargo(String json) {
        // Procesa un cargo en formato JSON
        return "Cargo procesado por ProveedorExterno con JSON: " + json;
    }
}

// Adapter
public class ProveedorExternoAdapter implements ProcesadorDePago {
    private final ProveedorExterno adaptee = new ProveedorExterno();

    @Override
    public String procesarPago(double monto) {
        // Adaptaci√≥n: convierte el double a un string JSON
        String jsonRequest = String.format("{\"monto\": %.2f}", monto);
        // Delega la llamada al objeto adaptado
        return adaptee.realizarCargo(jsonRequest);
    }
}

// Cliente
@Service
public class ServicioDePagos {
    public void ejecutarPago() {
        // El cliente trabaja con la interfaz Target, sin saber que es un adaptador
        ProcesadorDePago procesador = new ProveedorExternoAdapter();
        System.out.println(procesador.procesarPago(123.45));
    }
}
```

-----

## Ejemplo en Django (Python)

```python
from abc import ABC, abstractmethod
import json

# Target (La interfaz que tu sistema usa)
class ProcesadorDePago(ABC):
    @abstractmethod
    def procesar_pago(self, monto: float) -> str:
        pass

# Adaptee (La clase externa con interfaz incompatible)
class ProveedorExterno:
    def realizar_cargo(self, data: dict) -> str:
        return f"Cargo procesado por ProveedorExterno con datos: {data}"

# Adapter
class ProveedorExternoAdapter(ProcesadorDePago):
    def __init__(self):
        self._adaptee = ProveedorExterno()

    def procesar_pago(self, monto: float) -> str:
        # Adaptaci√≥n: convierte el float a un diccionario
        data_request = {"monto": monto}
        # Delega la llamada al objeto adaptado
        return self._adaptee.realizar_cargo(data_request)

# Cliente (una vista de Django)
from django.http import JsonResponse

def pagar_view(request):
    monto = 123.45
    # El cliente solo conoce la interfaz ProcesadorDePago
    procesador: ProcesadorDePago = ProveedorExternoAdapter()
    resultado = procesador.procesar_pago(monto)
    return JsonResponse({"resultado": resultado})
```

-----

## Resumen

  * El patr√≥n **Adapter** act√∫a como un **puente entre dos interfaces incompatibles**.
  * Utiliza un objeto para envolver al objeto "incompatible" (el adaptado).
  * Permite la colaboraci√≥n entre clases que no podr√≠an interactuar de otra manera, sin necesidad de modificar su c√≥digo fuente.

-----

# Pr√°ctica con Spring Boot

### Paso 1: Creaci√≥n del Proyecto en IntelliJ IDEA üöÄ

1.  Abre IntelliJ IDEA y ve a **File \> New \> Project...**.
2.  Selecciona **Spring Initializr**.
3.  Configura los metadatos:
      * **Name**: `adapter-ejemplo`
      * **Language**: **Java**
      * **Type**: **Gradle - Groovy**
      * **Group**: `com.example.solid`
      * **JDK**: **17** o superior
4.  Haz clic en **Next**.
5.  A√±ade la dependencia **Spring Web**.
6.  Haz clic en **Create**.

-----

### Paso 2: Estructura de Paquetes üìÇ

Dentro de `src/main/java/com/example/solid/adapterejemplo`, crea estos paquetes:

  * `target`: Para la interfaz est√°ndar de nuestro sistema.
  * `adaptee`: Para la clase externa que queremos adaptar.
  * `adapter`: Para la clase adaptadora.
  * `controller`: Para el `RestController` que actuar√° como cliente.

-----

### Paso 3: Codificaci√≥n del Patr√≥n Adapter üîå

#### 3.1. Crear la Interfaz `Target`

Dentro del paquete `target`, crea la interfaz que nuestro sistema utiliza.

**`ProcesadorPago.java`**

```java
package com.example.solid.adapterejemplo.target;

public interface ProcesadorPago {
    String procesarPago(double monto);
}
```

#### 3.2. Crear la Clase `Adaptee`

Dentro del paquete `adaptee`, simula la clase externa con una interfaz incompatible.

**`ProveedorPagoXML.java`**

```java
package com.example.solid.adapterejemplo.adaptee;

// Imagina que esta clase viene de una librer√≠a externa, por eso no es un @Component.
public class ProveedorPagoXML {
    public String realizarCargo(String xml) {
        System.out.println("Procesando cargo con el siguiente XML: " + xml);
        return "PAGO_EXITOSO_XML";
    }
}
```

#### 3.3. Crear el `Adapter`

Dentro del paquete `adapter`, crea la clase que conecta las dos interfaces.

**`ProveedorPagoXMLAdapter.java`**

```java
package com.example.solid.adapterejemplo.adapter;

import com.example.solid.adapterejemplo.adaptee.ProveedorPagoXML;
import com.example.solid.adapterejemplo.target.ProcesadorPago;
import org.springframework.stereotype.Component;

@Component // Hacemos que el adaptador sea un bean de Spring
public class ProveedorPagoXMLAdapter implements ProcesadorPago {

    private final ProveedorPagoXML adaptee = new ProveedorPagoXML();

    @Override
    public String procesarPago(double monto) {
        // 1. Adaptaci√≥n de datos: convertimos el double a un formato XML.
        String xmlRequest = String.format("<pago><monto>%.2f</monto></pago>", monto);
        
        // 2. Delegamos la llamada al objeto adaptado.
        return adaptee.realizarCargo(xmlRequest);
    }
}
```

-----

### Paso 4: Crear el Cliente (Controlador REST) üåê

El controlador solo conocer√° la interfaz `ProcesadorPago`. Spring se encargar√° de inyectar nuestra implementaci√≥n de adaptador.

**`PagoController.java`**

```java
package com.example.solid.adapterejemplo.controller;

import com.example.solid.adapterejemplo.target.ProcesadorPago;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/pagos")
public class PagoController {

    private final ProcesadorPago procesadorPago;

    // Spring busca un bean que implemente ProcesadorPago y encuentra nuestro Adapter.
    @Autowired
    public PagoController(ProcesadorPago procesadorPago) {
        this.procesadorPago = procesadorPago;
    }

    @GetMapping("/pagar/{monto}")
    public ResponseEntity<String> realizarPago(@PathVariable double monto) {
        // El controlador no sabe que est√° usando un adaptador, solo usa la interfaz est√°ndar.
        String resultado = procesadorPago.procesarPago(monto);
        return ResponseEntity.ok("Resultado del pago: " + resultado);
    }
}
```

-----

### Paso 5: Probar la Aplicaci√≥n ‚úÖ

1.  Ejecuta la aplicaci√≥n desde `AdapterEjemploApplication`.

2.  Usa tu navegador o `curl` para probar el endpoint:

    `http://localhost:8080/api/pagos/pagar/499.99`

    **Respuesta esperada en el navegador:**

    ```
    Resultado del pago: PAGO_EXITOSO_XML
    ```

    **Y en la consola de Spring Boot ver√°s el mensaje del `Adaptee`:**

    ```
    Procesando cargo con el siguiente XML: <pago><monto>499.99</monto></pago>
    ```

Esto demuestra que el controlador llam√≥ a la interfaz `ProcesadorPago`, pero el adaptador tradujo la llamada exitosamente para que el `ProveedorPagoXML` la procesara.

-----

# Pr√°ctica con Django (Python)

### Paso 1: Creaci√≥n del Proyecto en PyCharm üöÄ

1.  En PyCharm, ve a **File \> New Project...** y selecciona **Django**.
2.  Nombra el proyecto `adapter_django`.
3.  Crea una app inicial llamada `core`.

-----

### Paso 2: Estructura de la App Django üìÇ

1.  En la terminal de PyCharm, crea una nueva app:
    ```bash
    python manage.py startapp pagos
    ```
2.  A√±ade `'pagos'` a `INSTALLED_APPS` en `adapter_django/settings.py`.

-----

### Paso 3: Codificaci√≥n del Patr√≥n Adapter üîå

Dentro de la app `pagos`, crea los archivos y clases necesarios.

**`pagos/target.py` (La interfaz que tu sistema usa)**

```python
from abc import ABC, abstractmethod

class ProcesadorPago(ABC):
    @abstractmethod
    def procesar_pago(self, monto: float) -> str:
        pass
```

**`pagos/adaptee.py` (La clase externa incompatible)**

```python
class ProveedorPagoJSON:
    def realizar_cargo(self, data: dict) -> dict:
        print(f"Procesando cargo con JSON: {data}")
        return {"status": "SUCCESS", "tx_id": "xyz-123"}
```

**`pagos/adapter.py` (El adaptador)**

```python
from .target import ProcesadorPago
from .adaptee import ProveedorPagoJSON

class ProveedorPagoJSONAdapter(ProcesadorPago):
    def __init__(self):
        self._adaptee = ProveedorPagoJSON()

    def procesar_pago(self, monto: float) -> str:
        # 1. Adaptaci√≥n de datos: de float a dict
        json_data = {"amount": monto, "currency": "MXN"}
        
        # 2. Delegaci√≥n de la llamada
        response = self._adaptee.realizar_cargo(json_data)
        
        # 3. Adaptaci√≥n de la respuesta: de dict a string
        return f"Pago {response['status']} con ID de transacci√≥n {response['tx_id']}"
```

-----

### Paso 4: Crear el Cliente (La Vista de Django) üåê

Modifica `pagos/views.py`.

**`pagos/views.py`**

```python
from django.http import JsonResponse
from .adapter import ProveedorPagoJSONAdapter
from .target import ProcesadorPago

def realizar_pago(request, monto: float):
    # El cliente solo conoce la interfaz ProcesadorPago
    # y recibe una instancia que la cumple (nuestro adaptador).
    procesador: ProcesadorPago = ProveedorPagoJSONAdapter()
    
    resultado = procesador.procesar_pago(monto)
    
    return JsonResponse({"resultado_final": resultado})
```

-----

### Paso 5: Configurar las URLs y Probar ‚úÖ

1.  Crea `pagos/urls.py`:

    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('pagar/<float:monto>/', views.realizar_pago),
    ]
    ```

2.  Incluye estas URLs en `adapter_django/urls.py`:

    ```python
    from django.urls import path, include
    urlpatterns = [path('api/pagos/', include('pagos.urls'))]
    ```

3.  Ejecuta `python manage.py runserver` y prueba el endpoint:
    `http://127.0.0.1:8000/api/pagos/pagar/499.99/`

    **Respuesta esperada (JSON):**

    ```json
    {
        "resultado_final": "Pago SUCCESS con ID de transacci√≥n xyz-123"
    }
    ```

    Y en la consola de Django ver√°s la salida del `Adaptee`:

    ```
    Procesando cargo con JSON: {'amount': 499.99, 'currency': 'MXN'}
    ```