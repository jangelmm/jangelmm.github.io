---
title: 2.13 Bridge
published: 2025-10-14
tags: [DisenoEImplementacionSoftwareConPatrones, IngenieriaDeSoftware, Java, Python, Django, SpringBoot, ITO]
category: DisenoEImplementacionSoftwareConPatrones
draft: false
---

# Teor√≠a

## Definici√≥n 

El patr√≥n **Bridge (Puente)** es un patr√≥n de dise√±o **estructural** que te permite dividir una clase grande o un conjunto de clases estrechamente relacionadas en dos jerarqu√≠as separadas ‚Äî**abstracci√≥n** e **implementaci√≥n**‚Äî que pueden desarrollarse independientemente la una de la otra. Su prop√≥sito es **desacoplar una abstracci√≥n de su implementaci√≥n**, favoreciendo la **composici√≥n sobre la herencia**.

-----

## Problema

Imagina que tienes una clase `Notificacion` con subclases `NotificacionUrgente` y `NotificacionProgramada`. Ahora, quieres enviar estas notificaciones a trav√©s de diferentes canales: `Email`, `SMS` y `Push`.

Si usas herencia, te enfrentar√°s a una "explosi√≥n de clases":

  * `NotificacionUrgentePorEmail`, `NotificacionUrgentePorSMS`, `NotificacionUrgentePorPush`
  * `NotificacionProgramadaPorEmail`, `NotificacionProgramadaPorSMS`, `NotificacionProgramadaPorPush`

A√±adir un nuevo tipo de notificaci√≥n (`Informativa`) o un nuevo canal (`Webhook`) obliga a crear m√∫ltiples clases nuevas, haciendo el sistema r√≠gido y dif√≠cil de mantener.

-----

## Soluci√≥n

El patr√≥n Bridge extrae una de las dimensiones (el canal de env√≠o) a su propia jerarqu√≠a:

1.  **Jerarqu√≠a de Abstracci√≥n:** Las clases de `Notificacion` (`NotificacionUrgente`, etc.).
2.  **Jerarqu√≠a de Implementaci√≥n:** Una interfaz `CanalDeEnvio` con implementaciones concretas (`CanalEmail`, `CanalSMS`).
3.  La clase base `Notificacion` contiene una referencia (un "puente") a un objeto `CanalDeEnvio`.

Cuando una notificaci√≥n necesita ser enviada, delega la acci√≥n al objeto `CanalDeEnvio` que contiene. As√≠, puedes crear nuevos tipos de notificaci√≥n sin tocar los canales, y viceversa.

-----

## Estructura (Mermaid UML)

Este diagrama muestra el ejemplo cl√°sico de `Remote` y `Device`, que ilustra perfectamente la separaci√≥n de la Abstracci√≥n (el control) y la Implementaci√≥n (el dispositivo).

```mermaid
classDiagram
    direction TB

    class Remote {
        -device: Device
        +togglePower()
        +volumeUp()
    }
    note for Remote "Abstracci√≥n: Define la interfaz de alto nivel."

    class Device {
        <<Interface>>
        +isEnabled()
        +enable()
        +disable()
        +setVolume(percent)
    }
    note for Device "Implementaci√≥n: Define la interfaz para el trabajo real."

    class AdvancedRemote {
        +mute()
    }

    class TV {
        +enable()
        +setVolume(p)
    }
    class Radio {
        +enable()
        +setVolume(p)
    }

    Remote o-- Device : tiene un (el puente)
    Remote <|-- AdvancedRemote
    Device <|.. TV
    Device <|.. Radio
```

-----

## Cu√°ndo usar

  * Para dividir clases monol√≠ticas que tienen m√∫ltiples variantes de una funcionalidad.
  * Para extender clases en dimensiones independientes (ortogonales).
  * Cuando necesitas poder cambiar la implementaci√≥n en tiempo de ejecuci√≥n.

## Cu√°ndo no usar

  * Cuando tienes una sola dimensi√≥n que var√≠a. El patr√≥n a√±ade complejidad y no aporta beneficios si no hay dos jerarqu√≠as que evolucionen por separado.
  * Si el dise√±o ya es simple y cohesivo.

-----

## Ejemplo en Spring Boot (Java)

```java
// Implementaci√≥n (Interfaz)
public interface CanalDeEnvio {
    void enviarMensaje(String asunto, String mensaje);
}

// Implementaciones Concretas
public class CanalEmail implements CanalDeEnvio {
    public void enviarMensaje(String a, String m) { /* L√≥gica para enviar email */ }
}
public class CanalSMS implements CanalDeEnvio {
    public void enviarMensaje(String a, String m) { /* L√≥gica para enviar SMS */ }
}

// Abstracci√≥n
public abstract class Notificacion {
    protected CanalDeEnvio canal; // El puente

    public Notificacion(CanalDeEnvio canal) {
        this.canal = canal;
    }
    public abstract void notificar();
}

// Abstracci√≥n Refinada
public class NotificacionUrgente extends Notificacion {
    public NotificacionUrgente(CanalDeEnvio canal) { super(canal); }

    @Override
    public void notificar() {
        canal.enviarMensaje("¬°URGENTE!", "Este es un mensaje cr√≠tico.");
    }
}

// Cliente
@Service
public class SistemaDeAlertas {
    public void ejecutar() {
        // El cliente elige qu√© implementaci√≥n usar con qu√© abstracci√≥n
        CanalDeEnvio email = new CanalEmail();
        Notificacion notificacionUrgentePorEmail = new NotificacionUrgente(email);
        notificacionUrgentePorEmail.notificar();

        CanalDeEnvio sms = new CanalSMS();
        Notificacion notificacionUrgentePorSMS = new NotificacionUrgente(sms);
        notificacionUrgentePorSMS.notificar();
    }
}
```

-----

## Ejemplo en Django (Python)

```python
from abc import ABC, abstractmethod

# Implementaci√≥n (Interfaz)
class CanalDeEnvio(ABC):
    @abstractmethod
    def enviar_mensaje(self, asunto: str, mensaje: str) -> str:
        pass

# Implementaciones Concretas
class CanalEmail(CanalDeEnvio):
    def enviar_mensaje(self, asunto, mensaje):
        return f"Email enviado: '{asunto}' - '{mensaje}'"

class CanalSMS(CanalDeEnvio):
    def enviar_mensaje(self, asunto, mensaje):
        return f"SMS enviado: '{mensaje}' (Asunto ignorado)"

# Abstracci√≥n
class Notificacion(ABC):
    def __init__(self, canal: CanalDeEnvio):
        self._canal = canal  # El puente

    @abstractmethod
    def notificar(self) -> str:
        pass

# Abstracci√≥n Refinada
class NotificacionUrgente(Notificacion):
    def notificar(self) -> str:
        return self._canal.enviar_mensaje("¬°URGENTE!", "Este es un mensaje cr√≠tico.")

# Cliente (una vista de Django)
from django.http import JsonResponse

def enviar_alerta_view(request, canal_tipo: str):
    if canal_tipo == "email":
        canal = CanalEmail()
    elif canal_tipo == "sms":
        canal = CanalSMS()
    else:
        return JsonResponse({"error": "Canal no v√°lido"}, status=400)

    # El cliente conecta la abstracci√≥n con la implementaci√≥n
    notificacion = NotificacionUrgente(canal)
    resultado = notificacion.notificar()

    return JsonResponse({"resultado": resultado})
```

-----

## Resumen

  * El patr√≥n **Bridge** desacopla la **interfaz de control (Abstracci√≥n)** de la **implementaci√≥n de bajo nivel (Implementaci√≥n)**.
  * Utiliza la **composici√≥n** para evitar la explosi√≥n de clases que ocurrir√≠a con la herencia.
  * Permite que ambas jerarqu√≠as (abstracci√≥n e implementaci√≥n) evolucionen de forma independiente.

-----

# Pr√°ctica con Spring Boot

### Paso 1: Creaci√≥n del Proyecto en IntelliJ IDEA üöÄ

1.  Abre IntelliJ IDEA y ve a **File** \> **New** \> **Project...**.
2.  Selecciona **Spring Initializr**.
3.  Configura los metadatos:
      * **Name**: `bridge-ejemplo`
      * **Language**: **Java**
      * **Type**: **Gradle - Groovy**
      * **Group**: `com.example.solid`
      * **JDK**: **17** o superior
4.  Haz clic en **Next**.
5.  A√±ade la dependencia **Spring Web**.
6.  Haz clic en **Create**.

-----

### Paso 2: Estructura de Paquetes üìÇ

Dentro de `src/main/java/com/example/solid/bridgeejemplo`, crea estos paquetes:

  * `implementacion`: Contendr√° la interfaz del canal de env√≠o y sus implementaciones concretas.
  * `abstraccion`: Contendr√° la clase base `Notificacion` y sus subclases refinadas.
  * `controller`: Contendr√° el `RestController` que actuar√° como cliente.

-----

### Paso 3: Codificaci√≥n del Patr√≥n Bridge üåâ

#### 3.1. Crear la Jerarqu√≠a de Implementaci√≥n

Dentro del paquete `implementacion`, crea la interfaz y las clases concretas.

**`CanalDeEnvio.java` (Interfaz de Implementaci√≥n)**

```java
package com.example.solid.bridgeejemplo.implementacion;

public interface CanalDeEnvio {
    String enviarMensaje(String asunto, String mensaje);
}
```

**`CanalEmail.java` (Implementaci√≥n Concreta)**

```java
package com.example.solid.bridgeejemplo.implementacion;

import org.springframework.stereotype.Component;

@Component("email") // Le damos un nombre para inyectarla
public class CanalEmail implements CanalDeEnvio {
    @Override
    public String enviarMensaje(String asunto, String mensaje) {
        return String.format("Email enviado con asunto '%s': '%s'", asunto, mensaje);
    }
}
```

**`CanalSMS.java` (Implementaci√≥n Concreta)**

```java
package com.example.solid.bridgeejemplo.implementacion;

import org.springframework.stereotype.Component;

@Component("sms")
public class CanalSMS implements CanalDeEnvio {
    @Override
    public String enviarMensaje(String asunto, String mensaje) {
        // Los SMS no suelen tener asunto
        return String.format("SMS enviado: '%s'", mensaje);
    }
}
```

#### 3.2. Crear la Jerarqu√≠a de Abstracci√≥n

Dentro del paquete `abstraccion`, crea la clase base y las refinadas.

**`Notificacion.java` (Abstracci√≥n)**

```java
package com.example.solid.bridgeejemplo.abstraccion;

import com.example.solid.bridgeejemplo.implementacion.CanalDeEnvio;

public abstract class Notificacion {
    protected CanalDeEnvio canalDeEnvio; // El puente

    public Notificacion(CanalDeEnvio canalDeEnvio) {
        this.canalDeEnvio = canalDeEnvio;
    }

    public abstract String notificar(String mensaje);
}
```

**`NotificacionUrgente.java` (Abstracci√≥n Refinada)**

```java
package com.example.solid.bridgeejemplo.abstraccion;

import com.example.solid.bridgeejemplo.implementacion.CanalDeEnvio;

public class NotificacionUrgente extends Notificacion {
    public NotificacionUrgente(CanalDeEnvio canalDeEnvio) {
        super(canalDeEnvio);
    }

    @Override
    public String notificar(String mensaje) {
        return canalDeEnvio.enviarMensaje("¬°URGENTE!", mensaje);
    }
}
```

**`NotificacionNormal.java` (Abstracci√≥n Refinada)**

```java
package com.example.solid.bridgeejemplo.abstraccion;

import com.example.solid.bridgeejemplo.implementacion.CanalDeEnvio;

public class NotificacionNormal extends Notificacion {
    public NotificacionNormal(CanalDeEnvio canalDeEnvio) {
        super(canalDeEnvio);
    }

    @Override
    public String notificar(String mensaje) {
        return canalDeEnvio.enviarMensaje("Informativo", mensaje);
    }
}
```

-----

### Paso 4: Crear el Cliente (Controlador REST) üåê

Dentro del paquete `controller`, crea el `RestController`.

**`NotificacionController.java`**

```java
package com.example.solid.bridgeejemplo.controller;

import com.example.solid.bridgeejemplo.abstraccion.Notificacion;
import com.example.solid.bridgeejemplo.abstraccion.NotificacionNormal;
import com.example.solid.bridgeejemplo.abstraccion.NotificacionUrgente;
import com.example.solid.bridgeejemplo.implementacion.CanalDeEnvio;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
@RequestMapping("/api/notificaciones")
public class NotificacionController {

    private final Map<String, CanalDeEnvio> canales;

    public NotificacionController(Map<String, CanalDeEnvio> canales) {
        this.canales = canales;
    }

    @GetMapping("/enviar/{tipoNotificacion}/{tipoCanal}")
    public ResponseEntity<String> enviarNotificacion(@PathVariable String tipoNotificacion, @PathVariable String tipoCanal) {
        CanalDeEnvio canal = canales.get(tipoCanal);
        if (canal == null) {
            return ResponseEntity.badRequest().body("El canal no es v√°lido.");
        }

        Notificacion notificacion;
        String mensaje = "Revisar el estado del sistema.";

        // El cliente elige qu√© abstracci√≥n usar
        if ("urgente".equalsIgnoreCase(tipoNotificacion)) {
            notificacion = new NotificacionUrgente(canal);
        } else if ("normal".equalsIgnoreCase(tipoNotificacion)) {
            notificacion = new NotificacionNormal(canal);
        } else {
            return ResponseEntity.badRequest().body("El tipo de notificaci√≥n no es v√°lido.");
        }
        
        // El cliente "conecta" la abstracci√≥n con la implementaci√≥n
        String resultado = notificacion.notificar(mensaje);
        return ResponseEntity.ok(resultado);
    }
}
```

-----

### Paso 5: Probar la Aplicaci√≥n ‚úÖ

1.  Ejecuta la aplicaci√≥n desde `BridgeEjemploApplication`.
2.  Usa tu navegador o `curl` para probar los endpoints:

<!-- end list -->

  * **Notificaci√≥n urgente por email:**
    `http://localhost:8080/api/notificaciones/enviar/urgente/email`

    > **Respuesta:** `Email enviado con asunto '¬°URGENTE!': 'Revisar el estado del sistema.'`

  * **Notificaci√≥n urgente por SMS:**
    `http://localhost:8080/api/notificaciones/enviar/urgente/sms`

    > **Respuesta:** `SMS enviado: 'Revisar el estado del sistema.'`

  * **Notificaci√≥n normal por email:**
    `http://localhost:8080/api/notificaciones/enviar/normal/email`

    > **Respuesta:** `Email enviado con asunto 'Informativo': 'Revisar el estado del sistema.'`

-----

# Pr√°ctica con Django (Python)

### Paso 1: Creaci√≥n del Proyecto en PyCharm üöÄ

1.  En PyCharm, ve a **File** \> **New Project...** y selecciona **Django**.
2.  Nombra el proyecto `bridge_django`.
3.  Crea una app inicial llamada `core`.
4.  Haz clic en **Create**.

-----

### Paso 2: Estructura de la App Django üìÇ

1.  En la terminal de PyCharm, crea una nueva app:
    ```bash
    python manage.py startapp notificaciones
    ```
2.  A√±ade `'notificaciones'` a `INSTALLED_APPS` en `bridge_django/settings.py`.
3.  Dentro de `notificaciones`, crea los archivos `implementacion.py` y `abstraccion.py`.

-----

### Paso 3: Codificaci√≥n del Patr√≥n Bridge üåâ

#### 3.1. Crear la Jerarqu√≠a de Implementaci√≥n

**`notificaciones/implementacion.py`**

```python
from abc import ABC, abstractmethod

class CanalDeEnvio(ABC):
    @abstractmethod
    def enviar_mensaje(self, asunto: str, mensaje: str) -> str:
        pass

class CanalEmail(CanalDeEnvio):
    def enviar_mensaje(self, asunto, mensaje):
        return f"Email enviado con asunto '{asunto}': '{mensaje}'"

class CanalSMS(CanalDeEnvio):
    def enviar_mensaje(self, asunto, mensaje):
        return f"SMS enviado: '{mensaje}'"
```

#### 3.2. Crear la Jerarqu√≠a de Abstracci√≥n

**`notificaciones/abstraccion.py`**

```python
from abc import ABC, abstractmethod
from .implementacion import CanalDeEnvio

class Notificacion(ABC):
    def __init__(self, canal: CanalDeEnvio):
        self._canal = canal  # El puente

    @abstractmethod
    def notificar(self, mensaje: str) -> str:
        pass

class NotificacionUrgente(Notificacion):
    def notificar(self, mensaje: str) -> str:
        return self._canal.enviar_mensaje("¬°URGENTE!", mensaje)

class NotificacionNormal(Notificacion):
    def notificar(self, mensaje: str) -> str:
        return self._canal.enviar_mensaje("Informativo", mensaje)
```

-----

### Paso 4: Crear el Cliente (La Vista de Django) üåê

Modifica `notificaciones/views.py`.

**`notificaciones/views.py`**

```python
from django.http import JsonResponse
from .implementacion import CanalEmail, CanalSMS
from .abstraccion import NotificacionNormal, NotificacionUrgente

CANALES = {"email": CanalEmail, "sms": CanalSMS}
NOTIFICACIONES = {"normal": NotificacionNormal, "urgente": NotificacionUrgente}

def enviar_notificacion(request, tipo_notificacion: str, tipo_canal: str):
    canal_class = CANALES.get(tipo_canal)
    notificacion_class = NOTIFICACIONES.get(tipo_notificacion)

    if not canal_class or not notificacion_class:
        return JsonResponse({"error": "Tipo de canal o notificaci√≥n no v√°lido"}, status=400)
    
    # El cliente conecta la implementaci√≥n con la abstracci√≥n
    canal = canal_class()
    notificacion = notificacion_class(canal)
    
    mensaje = "Revisar el estado del sistema."
    resultado = notificacion.notificar(mensaje)

    return JsonResponse({"resultado": resultado})
```

-----

### Paso 5: Configurar las URLs y Probar ‚úÖ

1.  Crea `notificaciones/urls.py`:
    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('enviar/<str:tipo_notificacion>/<str:tipo_canal>/', views.enviar_notificacion),
    ]
    ```
2.  Incluye estas URLs en `bridge_django/urls.py`:
    ```python
    from django.urls import path, include
    urlpatterns = [path('api/notificaciones/', include('notificaciones.urls'))]
    ```
3.  Ejecuta `python manage.py runserver` y prueba los endpoints:
      * `http://127.0.0.1:8000/api/notificaciones/enviar/urgente/email/`
        > **Respuesta:** `{"resultado": "Email enviado con asunto '¬°URGENTE!': 'Revisar el estado del sistema.'"}`
      * `http://127.0.0.1:8000/api/notificaciones/enviar/normal/sms/`
        > **Respuesta:** `{"resultado": "SMS enviado: 'Revisar el estado del sistema.'"}`