---
title: 2.15 Singleton
published: 2025-10-20
tags: [DisenoEImplementacionSoftwareConPatrones, IngenieriaDeSoftware, Java, Python, Django, SpringBoot, ITO]
category: DisenoEImplementacionSoftwareConPatrones
draft: false
---

# Teor√≠a

## Definici√≥n ‚òùÔ∏è

El patr√≥n **Singleton** es un patr√≥n de dise√±o **creacional** que garantiza que una clase tenga **una sola instancia** en toda la aplicaci√≥n y proporciona un **punto de acceso global** a ella.

Es como tener una √∫nica llave maestra üîë para un recurso espec√≠fico: no importa qui√©n la pida, siempre recibir√° la misma llave.

-----

## Problema

Hay situaciones en las que necesitas asegurarte de que solo exista un objeto de un tipo particular. Algunos ejemplos comunes son:

  * **Gesti√≥n de Configuraci√≥n:** Cargar la configuraci√≥n de la aplicaci√≥n una sola vez y que todos los componentes accedan a la misma versi√≥n.
  * **Conexiones a Recursos:** Administrar un *pool* de conexiones a una base de datos o un gestor de logging centralizado.
  * **Servicios del Sistema Operativo:** Interactuar con un gestor de ventanas o un sistema de archivos, donde solo debe haber una instancia controladora.

Si permitieras crear m√∫ltiples instancias de estas clases, podr√≠as causar inconsistencias, consumir recursos innecesariamente o tener comportamientos inesperados (imagina dos objetos intentando escribir en el mismo archivo de log de forma descoordinada). Adem√°s, necesitar√≠as una forma f√°cil para que cualquier parte del c√≥digo acceda a esa √∫nica instancia.

-----

## Soluci√≥n

El patr√≥n Singleton resuelve esto implementando tres elementos clave dentro de la propia clase:

1.  **Constructor Privado:** Se impide que otras clases creen instancias directamente usando el operador `new` (o su equivalente).
2.  **Instancia Est√°tica Privada:** La clase guarda su √∫nica instancia en un campo est√°tico y privado.
3.  **M√©todo Est√°tico P√∫blico (`getInstance`)**: La clase proporciona un m√©todo est√°tico p√∫blico que devuelve la instancia √∫nica. La primera vez que se llama, crea la instancia; las siguientes veces, simplemente devuelve la instancia ya existente.

-----

## Estructura (Mermaid UML)

El diagrama es muy simple: la clase `Singleton` se referencia a s√≠ misma para guardar su √∫nica instancia y ofrece un m√©todo est√°tico para obtenerla.

```mermaid
classDiagram
    direction TB

    class Singleton {
        -Singleton instance
        -Singleton()
        +getInstance(): Singleton
        +someBusinessLogic()
    }
    note for Singleton "Guarda su propia instancia √∫nica\ny proporciona un m√©todo para acceder a ella."

    Singleton -- Singleton : instance
```

-----

## Cu√°ndo usar

  * Cuando necesitas **exactamente una instancia** de una clase, y esta debe ser accesible desde un punto bien conocido.
  * Cuando el objeto √∫nico debe ser extensible mediante subclases, y los clientes deben poder usar una instancia extendida sin cambiar su c√≥digo (aunque esto es menos com√∫n y m√°s complejo).

## Cu√°ndo no usar

  * **Viola el Principio de Responsabilidad √önica:** La clase se encarga tanto de su l√≥gica de negocio como de gestionar su propia instanciaci√≥n √∫nica.
  * **Introduce Acoplamiento Global:** Hace que el c√≥digo cliente dependa de una clase concreta global, dificultando las pruebas unitarias (no puedes reemplazar f√°cilmente el Singleton con un mock).
  * **Problemas en Multihilo:** La implementaci√≥n simple (`lazy initialization`) puede fallar si varios hilos intentan crear la instancia al mismo tiempo. Requiere sincronizaci√≥n cuidadosa.
  * **Frameworks Modernos:** Frameworks como Spring ya gestionan el ciclo de vida de los objetos y proporcionan Singletons por defecto (beans con scope singleton), haciendo la implementaci√≥n manual a menudo innecesaria.

-----

## Ejemplo en Java (Implementaci√≥n Cl√°sica)

```java
public class ConfiguracionGlobal {
    // 2. Instancia est√°tica privada (inicializaci√≥n temprana - thread-safe)
    private static final ConfiguracionGlobal instancia = new ConfiguracionGlobal();
    
    private String urlBaseDatos;

    // 1. Constructor privado
    private ConfiguracionGlobal() {
        // Simula la carga costosa de configuraci√≥n
        System.out.println("Cargando configuraci√≥n...");
        this.urlBaseDatos = "jdbc:mysql://localhost/produccion"; 
    }

    // 3. M√©todo est√°tico p√∫blico para obtener la instancia
    public static ConfiguracionGlobal getInstance() {
        return instancia;
    }

    // M√©todos de negocio
    public String getUrlBaseDatos() {
        return urlBaseDatos;
    }
}

// Cliente
public class Main {
    public static void main(String[] args) {
        ConfiguracionGlobal config1 = ConfiguracionGlobal.getInstance();
        ConfiguracionGlobal config2 = ConfiguracionGlobal.getInstance();

        System.out.println("URL: " + config1.getUrlBaseDatos());
        
        if (config1 == config2) {
            System.out.println("config1 y config2 son la misma instancia.");
        }
    }
}
```

-----

## Ejemplo en Python (Usando M√≥dulos - Idiom√°tico)

En Python, la forma m√°s sencilla y com√∫n de tener un Singleton es **usar un m√≥dulo**. Los m√≥dulos en Python se importan una sola vez por sesi√≥n, por lo que su estado es compartido globalmente.

```python
# config.py (Este m√≥dulo act√∫a como Singleton)
print("Cargando configuraci√≥n...")
url_base_datos = "jdbc:mysql://localhost/produccion"

def get_url():
    return url_base_datos

# main.py (Cliente 1)
import config

print(f"Main 1 - URL: {config.get_url()}")

# otro_modulo.py (Cliente 2)
import config

print(f"Otro M√≥dulo - URL: {config.get_url()}")

# Ejecuci√≥n (simulada):
# Cargando configuraci√≥n...  <-- Solo se imprime una vez
# Main 1 - URL: jdbc:mysql://localhost/produccion
# Otro M√≥dulo - URL: jdbc:mysql://localhost/produccion 
```

-----

## Resumen

  * El patr√≥n **Singleton** asegura **una √∫nica instancia** de una clase.
  * Proporciona un **punto de acceso global** a esa instancia.
  * Se implementa con un constructor privado y un m√©todo est√°tico `getInstance`.
  * Debe usarse con precauci√≥n debido a sus posibles desventajas (acoplamiento global, dificultad para pruebas).
  * En frameworks modernos como Spring, la gesti√≥n de Singletons suele estar integrada.

-----

# Pr√°ctica con Spring Boot

En Spring Boot, **los beans son Singletons por defecto**. No necesitas implementar el patr√≥n manualmente. Spring se encarga de crear una √∫nica instancia de tus componentes (`@Component`, `@Service`, `@Repository`, `@Controller`, `@Configuration`) y de inyectar esa misma instancia donde sea requerida.

### Paso 1: Creaci√≥n del Proyecto en IntelliJ IDEA üöÄ

1.  Abre IntelliJ IDEA y ve a **File \> New \> Project...**.
2.  Selecciona **Spring Initializr**.
3.  Configura los metadatos:
      * **Name**: `singleton-spring-ejemplo`
      * **Language**: **Java**
      * **Type**: **Gradle - Groovy**
      * **Group**: `com.example.solid`
      * **JDK**: **17** o superior
4.  Haz clic en **Next**.
5.  A√±ade la dependencia **Spring Web**.
6.  Haz clic en **Create**.

-----

### Paso 2: Estructura de Paquetes üìÇ

Dentro de `src/main/java/com/example/solid/singletonspringejemplo`, crea estos paquetes:

  * `config`: Para nuestra clase de configuraci√≥n Singleton.
  * `service`: Para un servicio que usar√° la configuraci√≥n.
  * `controller`: Para un controlador que tambi√©n usar√° la configuraci√≥n.

-----

### Paso 3: Codificaci√≥n del "Singleton" Gestionado por Spring ‚öôÔ∏è

#### 3.1. Crear la Clase Singleton

Dentro del paquete `config`, crea la clase. Spring la convertir√° en Singleton.

**`AppConfig.java`**

```java
package com.example.solid.singletonspringejemplo.config;

import org.springframework.stereotype.Component;
import jakarta.annotation.PostConstruct;

@Component // ¬°Esta anotaci√≥n le dice a Spring que gestione esta clase como un bean Singleton!
public class AppConfig {

    private String databaseUrl;
    private int maxConnections;

    public AppConfig() {
        System.out.println("****** AppConfig CONSTRUCTOR LLAMADO ******");
        // Simula la carga de configuraci√≥n
        this.databaseUrl = "jdbc:h2:mem:testdb";
        this.maxConnections = 10;
    }

    @PostConstruct // Se ejecuta despu√©s de que el constructor termina
    public void init() {
        System.out.println("****** AppConfig INICIALIZADO (@PostConstruct) ******");
        System.out.println("Configuraci√≥n cargada: DB URL=" + databaseUrl + ", Max Conexiones=" + maxConnections);
    }

    // Getters
    public String getDatabaseUrl() { return databaseUrl; }
    public int getMaxConnections() { return maxConnections; }
}
```

  * **`@Component`**: Es la clave. Le indica a Spring: "Crea una √∫nica instancia de esta clase y gu√°rdala".

-----

### Paso 4: Crear Clientes que Usen el Singleton

#### 4.1. Crear un Servicio

Dentro del paquete `service`, crea una clase que pida la configuraci√≥n.

**`UserService.java`**

```java
package com.example.solid.singletonspringejemplo.service;

import com.example.solid.singletonspringejemplo.config.AppConfig;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private final AppConfig appConfig;

    // Spring inyecta la √öNICA instancia de AppConfig aqu√≠
    public UserService(AppConfig appConfig) {
        System.out.println("****** UserService CONSTRUCTOR - Recibiendo AppConfig: " + appConfig.hashCode() + " ******");
        this.appConfig = appConfig;
    }

    public String getUserConfigInfo() {
        return "UserService usando DB URL: " + appConfig.getDatabaseUrl();
    }
}
```

#### 4.2. Crear un Controlador

Dentro del paquete `controller`, crea otra clase que tambi√©n pida la configuraci√≥n.

**`ConfigController.java`**

```java
package com.example.solid.singletonspringejemplo.controller;

import com.example.solid.singletonspringejemplo.config.AppConfig;
import com.example.solid.singletonspringejemplo.service.UserService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/config")
public class ConfigController {

    private final AppConfig appConfig;
    private final UserService userService;

    // Spring inyecta la MISMA instancia de AppConfig aqu√≠
    public ConfigController(AppConfig appConfig, UserService userService) {
        System.out.println("****** ConfigController CONSTRUCTOR - Recibiendo AppConfig: " + appConfig.hashCode() + " ******");
        this.appConfig = appConfig;
        this.userService = userService;
    }

    @GetMapping("/info")
    public String getConfigInfo() {
        String controllerInfo = "ConfigController usando Max Conexiones: " + appConfig.getMaxConnections();
        String serviceInfo = userService.getUserConfigInfo();
        
        // Comprobaremos si ambas clases recibieron la misma instancia
        return controllerInfo + " | " + serviceInfo + 
               " | HashCode de AppConfig en Controller: " + appConfig.hashCode();
    }
}
```

  * **`hashCode()`**: Usamos `hashCode()` para obtener un identificador √∫nico del objeto en memoria. Si los hash codes son iguales, significa que es la misma instancia.

-----

### Paso 5: Probar la Aplicaci√≥n ‚úÖ

1.  Ejecuta la aplicaci√≥n desde `SingletonSpringEjemploApplication`.

2.  **Observa la Consola:** Ver√°s los mensajes `****** ... ******`. Notar√°s que el constructor de `AppConfig` y su m√©todo `init` se llaman **solo una vez** al inicio. Luego, ver√°s que tanto `UserService` como `ConfigController` reciben un `AppConfig` con el **mismo hash code**.

3.  Usa tu navegador o `curl` para probar el endpoint:
    `http://localhost:8080/api/config/info`

    **Respuesta esperada (el hash code puede variar):**

    ```
    ConfigController usando Max Conexiones: 10 | UserService usando DB URL: jdbc:h2:mem:testdb | HashCode de AppConfig en Controller: 123456789 
    ```

    El hash code mostrado ser√° el mismo que viste en la consola, confirmando que ambos componentes usan la **√∫nica instancia** de `AppConfig` creada por Spring.

-----

# Pr√°ctica con Django (Python)

Como mencionamos en la teor√≠a, en Python la forma m√°s idiom√°tica de lograr un Singleton es usando **m√≥dulos**. Cuando importas un m√≥dulo, Python lo carga en memoria una sola vez y reutiliza esa misma instancia cada vez que se importa de nuevo.

### Paso 1: Creaci√≥n del Proyecto en PyCharm üöÄ

1.  En PyCharm, ve a **File \> New Project...** y selecciona **Django**.
2.  Nombra el proyecto `singleton_django` y crea una app inicial `core`.

-----

### Paso 2: Estructura de la App Django üìÇ

1.  En la terminal, crea una nueva app:
```bash
python manage.py startapp config_app
```
1.  A√±ade `'config_app'` a `INSTALLED_APPS` en `singleton_django/settings.py`.

-----

### Paso 3: Codificaci√≥n del "Singleton" como M√≥dulo ‚öôÔ∏è

Dentro de la app `config_app`, crea un archivo para nuestra configuraci√≥n.

**`config_app/app_config.py`**

```python
# Este m√≥dulo completo act√∫a como un Singleton.
# El c√≥digo aqu√≠ solo se ejecuta UNA VEZ cuando se importa por primera vez.

print("****** Cargando app_config.py (¬°Deber√≠a pasar solo una vez!) ******")

# Estado global compartido
_database_url = "jdbc:h2:mem:testdb_django"
_max_connections = 5
_carga_inicial_completa = False

def inicializar_configuracion():
    global _carga_inicial_completa
    if not _carga_inicial_completa:
        print("****** Realizando inicializaci√≥n costosa... ******")
        # Simula una carga pesada
        import time
        time.sleep(1) # Espera 1 segundo
        _carga_inicial_completa = True
        print("****** Inicializaci√≥n completada ******")

def get_database_url():
    inicializar_configuracion() # Asegura que la inicializaci√≥n ocurra antes de usar
    return _database_url

def get_max_connections():
    inicializar_configuracion()
    return _max_connections

# Llama a la inicializaci√≥n al cargar el m√≥dulo si es necesario
# inicializar_configuracion() # Opcional: podr√≠as llamarla aqu√≠ directamente
```

  * Todo lo que est√° definido en este archivo (`_database_url`, `get_database_url`, etc.) existir√° en una **√∫nica instancia** en memoria una vez que el m√≥dulo sea importado.

-----

### Paso 4: Crear Clientes que Usen el M√≥dulo Singleton

Crearemos dos vistas diferentes que importen y usen `app_config`.

**`config_app/views.py`**

```python
from django.http import JsonResponse
# Importamos nuestro m√≥dulo Singleton
from . import app_config 
import random 

def vista_uno(request):
    print(f"****** Vista Uno - Usando app_config ID: {id(app_config)} ******")
    
    # Accede a la configuraci√≥n
    db_url = app_config.get_database_url()
    
    # Simulamos un cambio (aunque no es buena pr√°ctica modificar config global as√≠)
    # Solo para demostrar que es el mismo objeto
    if random.random() < 0.5: 
         app_config._database_url = "jdbc:h2:mem:testdb_django_MODIFICADO"
         print("****** Vista Uno - URL MODIFICADA ******")
         
    return JsonResponse({
        "vista": "uno",
        "db_url": db_url,
        "max_conn": app_config.get_max_connections(),
        "config_id": id(app_config) # ID del objeto m√≥dulo en memoria
    })

def vista_dos(request):
    print(f"****** Vista Dos - Usando app_config ID: {id(app_config)} ******")
    
    # Accede a la configuraci√≥n (la misma instancia que vista_uno)
    db_url = app_config.get_database_url() 
    
    return JsonResponse({
        "vista": "dos",
        "db_url": db_url, 
        "max_conn": app_config.get_max_connections(),
        "config_id": id(app_config) # Deber√≠a ser el mismo ID que en vista_uno
    })
```

  * **`id(app_config)`**: Devuelve el identificador √∫nico del objeto `app_config` en memoria. Si es el mismo en ambas vistas, confirma que es la misma instancia.

-----

### Paso 5: Configurar las URLs y Probar ‚úÖ

1.  Crea `config_app/urls.py`:

    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('vista1/', views.vista_uno),
        path('vista2/', views.vista_dos),
    ]
    ```

2.  Incluye estas URLs en `singleton_django/urls.py`:

    ```python
    from django.urls import path, include
    urlpatterns = [path('api/config/', include('config_app.urls'))]
    ```

3.  Ejecuta `python manage.py runserver`.

4.  **Observa la Consola del Servidor:** Al iniciar, deber√≠as ver el mensaje `"****** Cargando app_config.py ... ******"` **una sola vez**. Tambi√©n ver√°s el mensaje de inicializaci√≥n costosa la primera vez que una vista lo llame.

5.  Prueba los endpoints en tu navegador varias veces y en diferente orden:

      * `http://127.0.0.1:8000/api/config/vista1/`
      * `http://127.0.0.1:8000/api/config/vista2/`

    **Respuestas esperadas (JSON, los IDs ser√°n iguales):**

    ```json
    // Para vista1
    {
        "vista": "uno",
        "db_url": "jdbc:h2:mem:testdb_django", // O la versi√≥n modificada
        "max_conn": 5,
        "config_id": 1401234567890 
    }
    ```

    ```json
    // Para vista2
    {
        "vista": "dos",
        "db_url": "jdbc:h2:mem:testdb_django", // Ver√°s la versi√≥n modificada si vista1 la cambi√≥
        "max_conn": 5,
        "config_id": 1401234567890 // MISMO ID que en vista1
    }
    ```

    El hecho de que el `config_id` sea el mismo y que los cambios hechos en `vista_uno` (la modificaci√≥n de la URL) se reflejen en `vista_dos` demuestra que ambas est√°n interactuando con la **√∫nica instancia** del m√≥dulo `app_config`.