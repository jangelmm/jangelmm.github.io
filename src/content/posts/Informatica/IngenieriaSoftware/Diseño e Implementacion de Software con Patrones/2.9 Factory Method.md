---
title: 2.9 Factory Method
published: 2025-10-09
tags: [DisenoEImplementacionSoftwareConPatrones, IngenieriaDeSoftware, Java, Python, Django, SpringBoot, ITO]
category: DisenoEImplementacionSoftwareConPatrones
draft: false
---

# Teor√≠a
## Definici√≥n

El **Factory Method** (M√©todo F√°brica o Constructor Virtual) es un **patr√≥n de dise√±o creacional** que:

* Proporciona una interfaz com√∫n para crear objetos en una superclase.
* Permite que las subclases decidan qu√© clase concreta de objeto instanciar.
* Desacopla la l√≥gica del cliente de la creaci√≥n de objetos espec√≠ficos.

---

## Problema

Si el c√≥digo cliente est√° acoplado a clases concretas, cada vez que se quiera a√±adir un nuevo producto (por ejemplo, transporte terrestre, mar√≠timo o a√©reo), ser√° necesario modificar varias partes del sistema. Esto genera c√≥digo dif√≠cil de mantener y extender.

---

## Soluci√≥n

* Definir una **interfaz de producto com√∫n** (ej. `Transporte`).
* Definir un **m√©todo f√°brica** en una clase creadora (ej. `Logistica`) que devuelve productos de esa interfaz.
* Las subclases de la creadora implementan el m√©todo y devuelven un tipo espec√≠fico (ej. `Camion`, `Barco`).

---

## Estructura (Mermaid UML)

```mermaid
classDiagram
    class Transporte {
        <<interface>>
        +entregar(): void
    }

    class Camion {
        +entregar(): void
    }

    class Barco {
        +entregar(): void
    }

    class Logistica {
        <<abstract>>
        +crearTransporte(): Transporte
    }

    class LogisticaTerrestre {
        +crearTransporte(): Transporte
    }

    class LogisticaMaritima {
        +crearTransporte(): Transporte
    }

    Transporte <|.. Camion
    Transporte <|.. Barco
    Logistica <|-- LogisticaTerrestre
    Logistica <|-- LogisticaMaritima
    Logistica --> Transporte
```

---

## Cu√°ndo usar

* Cuando el c√≥digo debe **trabajar con una interfaz com√∫n** y no con implementaciones concretas.
* Cuando se espera que **la familia de productos crezca** en el futuro.

## Cu√°ndo no usar

* Cuando el n√∫mero de productos es peque√±o y estable (es m√°s simple usar constructores directos).
* Cuando la herencia genera sobrecarga innecesaria.

---

## Ejemplo en Spring Boot (Java)

```java
// Producto
public interface Transporte {
    void entregar();
}

// Productos concretos
public class Camion implements Transporte {
    @Override
    public void entregar() {
        System.out.println("Entrega por carretera en cami√≥n");
    }
}

public class Barco implements Transporte {
    @Override
    public void entregar() {
        System.out.println("Entrega por mar en barco");
    }
}

// Creador abstracto
public abstract class Logistica {
    public abstract Transporte crearTransporte();

    public void planEntrega() {
        Transporte transporte = crearTransporte();
        transporte.entregar();
    }
}

// Creadores concretos
public class LogisticaTerrestre extends Logistica {
    @Override
    public Transporte crearTransporte() {
        return new Camion();
    }
}

public class LogisticaMaritima extends Logistica {
    @Override
    public Transporte crearTransporte() {
        return new Barco();
    }
}

// Cliente (ejemplo de uso en un CommandLineRunner de Spring Boot)
@SpringBootApplication
public class FactoryMethodApp implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(FactoryMethodApp.class, args);
    }

    @Override
    public void run(String... args) {
        Logistica terrestre = new LogisticaTerrestre();
        terrestre.planEntrega();

        Logistica maritima = new LogisticaMaritima();
        maritima.planEntrega();
    }
}
```

---

## Ejemplo en Django (Python)

```python
from abc import ABC, abstractmethod

# Producto
class Transporte(ABC):
    @abstractmethod
    def entregar(self):
        pass

# Productos concretos
class Camion(Transporte):
    def entregar(self):
        return "Entrega por carretera en cami√≥n"

class Barco(Transporte):
    def entregar(self):
        return "Entrega por mar en barco"

# Creador abstracto
class Logistica(ABC):
    @abstractmethod
    def crear_transporte(self) -> Transporte:
        pass

    def plan_entrega(self):
        transporte = self.crear_transporte()
        return transporte.entregar()

# Creadores concretos
class LogisticaTerrestre(Logistica):
    def crear_transporte(self) -> Transporte:
        return Camion()

class LogisticaMaritima(Logistica):
    def crear_transporte(self) -> Transporte:
        return Barco()

# Uso en una vista de Django
from django.http import JsonResponse

def entrega_view(request, tipo):
    if tipo == "tierra":
        logistica = LogisticaTerrestre()
    elif tipo == "mar":
        logistica = LogisticaMaritima()
    else:
        return JsonResponse({"error": "Tipo de transporte no v√°lido"}, status=400)

    return JsonResponse({"resultado": logistica.plan_entrega()})
```

---

## Resumen

* El **Factory Method** permite crear objetos sin acoplar el c√≥digo cliente a clases concretas.
* Sigue los principios de **abierto/cerrado** y **responsabilidad √∫nica**.
* Es aplicable en frameworks como Spring Boot o Django para encapsular la creaci√≥n de objetos dependientes del negocio.

# Pr√°ctica con Spring Boot

### Paso 1: Creaci√≥n del Proyecto en IntelliJ IDEA üöÄ

Primero, vamos a recrear el proyecto desde cero para tener una gu√≠a completa.

1.  Abre IntelliJ IDEA y ve a **File** \> **New** \> **Project...**.
2.  En la ventana que aparece, selecciona **Spring Initializr** en el panel izquierdo.
3.  Configura los metadatos de tu proyecto.
      * **Name**: `Factory-Method-Ejemplo`
      * **Location**: La carpeta donde quieras guardarlo.
      * **Language**: **Java**
      * **Type**: **Gradle - Groovy**
      * **Group**: `com.example.solid`
      * **Artifact**: `factorymethodejemplo`
      * **JDK**: Aseg√∫rate de seleccionar la **versi√≥n 17** (o superior).
      * **Packaging**: **Jar**
4.  Haz clic en **Next**.
5.  Ahora, elige las dependencias. Para este proyecto, solo necesitas **Spring Web**.
6.  Haz clic en **Create**. IntelliJ generar√° la estructura del proyecto.

-----

### Paso 2: Estructura de Paquetes üìÇ

Una buena organizaci√≥n es clave. Dentro de `src/main/java/com/example/solid/factorymethodejemplo`, crearemos los siguientes paquetes para mantener nuestro c√≥digo ordenado:

  * `transport`: Contendr√° la interfaz del producto (`Transporte`) y sus implementaciones concretas (`Camion`, `Barco`).
  * `factory`: Contendr√° la clase creadora abstracta (`Logistica`) y sus implementaciones concretas (`LogisticaTerrestre`, `LogisticaMaritima`).
  * `controller`: Contendr√° nuestro `RestController`, que actuar√° como el cliente del patr√≥n.

-----

### Paso 3: Codificaci√≥n del Patr√≥n Factory Method üè≠

Ahora vamos a escribir el c√≥digo, siguiendo la estructura que definimos.

#### 3.1. Crear los Productos (Interfaz y Clases Concretas) üöö

Dentro del paquete `transport`, crea estas tres clases.

**`Transporte.java` (La Interfaz del Producto)**

```java
package com.example.solid.factorymethodejemplo.transport;

public interface Transporte {
    String entregar();
}
```

**`Camion.java` (Producto Concreto)**

```java
package com.example.solid.factorymethodejemplo.transport;

import org.springframework.stereotype.Component;

@Component
public class Camion implements Transporte {
    @Override
    public String entregar() {
        return "Entrega por carretera en un cami√≥n.";
    }
}
```

**`Barco.java` (Producto Concreto)**

```java
package com.example.solid.factorymethodejemplo.transport;

import org.springframework.stereotype.Component;

@Component
public class Barco implements Transporte {
    @Override
    public String entregar() {
        return "Entrega por mar en un barco.";
    }
}
```

#### 3.2. Crear los Creadores (Clase Abstracta y F√°bricas Concretas)

Ahora, en el paquete `factory`, crea la clase abstracta y las dos f√°bricas concretas.

**`Logistica.java` (El Creador Abstracto)**

```java
package com.example.solid.factorymethodejemplo.factory;

import com.example.solid.factorymethodejemplo.transport.Transporte;

public abstract class Logistica {

    // Este es el "Factory Method" que las subclases deben implementar
    public abstract Transporte crearTransporte();

    public String planificarEntrega() {
        Transporte transporte = crearTransporte();
        return transporte.entregar();
    }
}
```

**`LogisticaTerrestre.java` (Creador Concreto)**

```java
package com.example.solid.factorymethodejemplo.factory;

import com.example.solid.factorymethodejemplo.transport.Camion;
import com.example.solid.factorymethodejemplo.transport.Transporte;
import org.springframework.stereotype.Component;

@Component("terrestre") // Nombre clave para identificar esta f√°brica
public class LogisticaTerrestre extends Logistica {
    @Override
    public Transporte crearTransporte() {
        return new Camion();
    }
}
```

**`LogisticaMaritima.java` (Creador Concreto)**

```java
package com.example.solid.factorymethodejemplo.factory;

import com.example.solid.factorymethodejemplo.transport.Barco;
import com.example.solid.factorymethodejemplo.transport.Transporte;
import org.springframework.stereotype.Component;

@Component("maritima") // Nombre clave para esta otra f√°brica
public class LogisticaMaritima extends Logistica {
    @Override
    public Transporte crearTransporte() {
        return new Barco();
    }
}
```

-----

### Paso 4: Crear el Cliente (Controlador REST) üåê

Finalmente, en el paquete `controller`, crearemos la clase que utiliza las f√°bricas para construir los productos. Usaremos la inyecci√≥n de dependencias de Spring para que elija la f√°brica correcta por nosotros.

**`LogisticaController.java`**

```java
package com.example.solid.factorymethodejemplo.controller;

import com.example.solid.factorymethodejemplo.factory.Logistica;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/logistica")
public class LogisticaController {

    // Spring inyecta un mapa con todas las f√°bricas. La clave es el nombre
    // que pusimos en @Component ("terrestre", "maritima").
    private final Map<String, Logistica> logisticaMap;

    @Autowired
    public LogisticaController(Map<String, Logistica> logisticaMap) {
        this.logisticaMap = logisticaMap;
    }

    @GetMapping("/entrega/{tipo}")
    public ResponseEntity<String> realizarEntrega(@PathVariable String tipo) {
        // Buscamos la f√°brica correcta seg√∫n el "tipo" de la URL.
        return Optional.ofNullable(logisticaMap.get(tipo))
                .map(logistica -> {
                    // Si la encontramos, planificamos la entrega.
                    // El controlador no sabe qu√© tipo de transporte se est√° creando.
                    String resultado = logistica.planificarEntrega();
                    return ResponseEntity.ok(resultado);
                })
                .orElse(ResponseEntity.badRequest().body("Tipo de log√≠stica no v√°lido: " + tipo));
    }
}
```

-----

### Paso 5: Probar la Aplicaci√≥n ‚úÖ

¬°Todo est√° listo\!

1.  Ejecuta tu aplicaci√≥n desde la clase principal `FactoryMethodEjemploApplication`.
2.  Usa un navegador para probar los siguientes endpoints:

<!-- end list -->

  * **Para la entrega terrestre:**
    `http://localhost:8080/api/logistica/entrega/terrestre`

    **Respuesta esperada:**

    ```
    Entrega por carretera en un cami√≥n.
    ```

  * **Para la entrega mar√≠tima:**
    `http://localhost:8080/api/logistica/entrega/maritima`

    **Respuesta esperada:**

    ```
    Entrega por mar en un barco.
    ```

  * **Para un tipo no existente:**
    `http://localhost:8080/api/logistica/entrega/aerea`

    **Respuesta esperada:**

    ```
    Tipo de log√≠stica no v√°lido: aerea
    ```

# Pr√°ctica con Django

### Paso 1: Creaci√≥n del Proyecto en PyCharm üöÄ

Primero, vamos a crear un proyecto Django nuevo y limpio.

1.  Abre PyCharm (la versi√≥n Professional es ideal para esto) y ve a **File** \> **New** \> **Project...**.
2.  En la ventana que aparece, selecciona **Django** en el panel izquierdo.
3.  Configura tu proyecto:
      * **Location**: Elige una carpeta y nombra el proyecto, por ejemplo, `factory_method_django`.
      * **New environment using**: Selecciona **Virtualenv**. Esto crear√° un entorno virtual aislado para tu proyecto, lo cual es una pr√°ctica recomendada en Python.
      * **Application name**: Puedes nombrar tu primera aplicaci√≥n, por ejemplo, `core`.
4.  Haz clic en **Create**. PyCharm configurar√° el entorno, instalar√° Django y generar√° la estructura b√°sica del proyecto.

-----

### Paso 2: Estructura de Archivos y Aplicaci√≥n Django üìÇ

En Django, la l√≥gica se organiza en "apps". Crearemos una app espec√≠fica para nuestra funcionalidad de log√≠stica.

Antes te recomiendo instalar en una terminal
```
pip install django
pip lis 
```

1.  Abre la terminal dentro de PyCharm (**View** \> **Tool Windows** \> **Terminal**).
2.  Ejecuta el siguiente comando para crear una nueva app llamada `logistica`:
    ```bash
    python manage.py startapp logistica
    ```
3.  Ahora, debemos registrar esta nueva app en nuestro proyecto. Abre el archivo `factory_method_django/settings.py` y a√±ade `'logistica'` a la lista de `INSTALLED_APPS`:
    ```python
    # factory_method_django/settings.py

    INSTALLED_APPS = [
        # ... otras apps
        'django.contrib.staticfiles',
        'logistica', # A√±ade tu app aqu√≠
    ]
    ```

Dentro de la carpeta `logistica`, organizaremos nuestro patr√≥n en diferentes archivos para mayor claridad: `products.py`, `factories.py`, y modificaremos `views.py`.

-----

### Paso 3: Codificaci√≥n del Patr√≥n Factory Method üè≠

Ahora vamos a escribir el c√≥digo Python. Usaremos el m√≥dulo `abc` para crear clases abstractas, el equivalente a las interfaces de Java para este caso.

#### 3.1. Crear los Productos (Clase Abstracta y Concretas) üöö

1.  Dentro de la carpeta `logistica`, crea un nuevo archivo llamado `products.py`.
2.  A√±ade el siguiente c√≥digo:

**`logistica/products.py`**

```python
from abc import ABC, abstractmethod

# La clase abstracta base (equivalente a la interfaz)
class Transporte(ABC):
    @abstractmethod
    def entregar(self) -> str:
        pass

# Producto Concreto
class Camion(Transporte):
    def entregar(self) -> str:
        return "Entrega por carretera en un cami√≥n."

# Producto Concreto
class Barco(Transporte):
    def entregar(self) -> str:
        return "Entrega por mar en un barco."
```

#### 3.2. Crear los Creadores (Clase Abstracta y F√°bricas Concretas)

1.  Dentro de la carpeta `logistica`, crea otro archivo nuevo llamado `factories.py`.
2.  A√±ade el siguiente c√≥digo:

**`logistica/factories.py`**

```python
from abc import ABC, abstractmethod
from .products import Transporte, Camion, Barco

# El Creador Abstracto
class Logistica(ABC):
    # Este es el "Factory Method"
    @abstractmethod
    def crear_transporte(self) -> Transporte:
        pass

    def planificar_entrega(self) -> str:
        transporte = self.crear_transporte()
        return transporte.entregar()

# Creador Concreto
class LogisticaTerrestre(Logistica):
    def crear_transporte(self) -> Transporte:
        return Camion()

# Creador Concreto
class LogisticaMaritima(Logistica):
    def crear_transporte(self) -> Transporte:
        return Barco()
```

-----

### Paso 4: Crear el Cliente (La Vista de Django) üåê

El "cliente" en Django ser√° una vista que recibe la petici√≥n HTTP, elige la f√°brica correcta y devuelve una respuesta.

Modifica el archivo `logistica/views.py` que se cre√≥ autom√°ticamente.

**`logistica/views.py`**

```python
from django.http import JsonResponse
from .factories import Logistica, LogisticaTerrestre, LogisticaMaritima

# Un mapa para registrar nuestras f√°bricas.
# Esto nos permite a√±adir nuevas f√°bricas sin tocar esta vista.
FABRICAS_DISPONIBLES = {
    "terrestre": LogisticaTerrestre,
    "maritima": LogisticaMaritima,
}

def realizar_entrega(request, tipo: str):
    """
    Esta vista act√∫a como el cliente del patr√≥n Factory Method.
    """
    # 1. Busca la clase de la f√°brica correcta en nuestro mapa.
    fabrica_class = FABRICAS_DISPONIBLES.get(tipo)

    if not fabrica_class:
        return JsonResponse({"error": f"Tipo de log√≠stica no v√°lido: {tipo}"}, status=400)

    # 2. Instancia la f√°brica seleccionada.
    fabrica: Logistica = fabrica_class()

    # 3. Usa la f√°brica para planificar la entrega, sin saber qu√© producto se crea.
    resultado = fabrica.planificar_entrega()

    return JsonResponse({"mensaje": resultado})
```

-----

### Paso 5: Configurar las URLs üîó

Necesitamos decirle a Django qu√© URL debe activar nuestra vista.

1.  Dentro de la carpeta `logistica`, crea un nuevo archivo `urls.py`.
    **`logistica/urls.py`**

    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('entrega/<str:tipo>/', views.realizar_entrega, name='realizar_entrega'),
    ]
    ```

2.  Ahora, incluye estas URLs en el archivo principal de URLs del proyecto.
    **`factory_method_django/urls.py`**

    ```python
    from django.contrib import admin
    from django.urls import path, include # Aseg√∫rate de importar "include"

    urlpatterns = [
        path('admin/', admin.site.urls),
        # A√±ade esta l√≠nea para conectar las URLs de tu app
        path('api/logistica/', include('logistica.urls')),
    ]
    ```

-----

### Paso 6: Probar la Aplicaci√≥n ‚úÖ

¬°Todo est√° configurado\!

1.  En la terminal de PyCharm, ejecuta el servidor de desarrollo de Django:
    ```bash
    python manage.py runserver
    ```
2.  Usa un navegador o `curl` para probar los siguientes endpoints:

<!-- end list -->

  * **Para la entrega terrestre:**
    `http://127.0.0.1:8000/api/logistica/entrega/terrestre/`

    **Respuesta esperada (JSON):**

    ```json
    {
        "mensaje": "Entrega por carretera en un cami√≥n."
    }
    ```

  * **Para la entrega mar√≠tima:**
    `http://127.0.0.1:8000/api/logistica/entrega/maritima/`

    **Respuesta esperada (JSON):**

    ```json
    {
        "mensaje": "Entrega por mar en un barco."
    }
    ```

  * **Para un tipo no existente:**
    `http://127.0.0.1:8000/api/logistica/entrega/aerea/`

    **Respuesta esperada (JSON con c√≥digo 400):**

    ```json
    {
        "error": "Tipo de log√≠stica no v√°lido: aerea"
    }
    ```

Con estos pasos, has implementado exitosamente el patr√≥n Factory Method en un proyecto Django, manteniendo tu c√≥digo desacoplado y listo para expandirse con nuevos tipos de transporte sin necesidad de modificar la l√≥gica del cliente.